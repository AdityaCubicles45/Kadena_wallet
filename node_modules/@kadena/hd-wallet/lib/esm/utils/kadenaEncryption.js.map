{"version":3,"file":"kadenaEncryption.js","sourceRoot":"","sources":["../../../src/utils/kadenaEncryption.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BinaryLike } from './crypto.js';\nimport { decrypt, encrypt, randomBytes } from './crypto.js';\n\n/**\n * @public\n */\nexport type EncryptedString = string & { _brand: 'EncryptedString' };\n\n/**\n * Encrypts the message with a password .\n * @param message - The message to be encrypted.\n * @param password - password used for encryption.\n * @returns The encrypted string\n * @public\n */\nexport async function kadenaEncrypt<\n  TEncode extends 'base64' | 'buffer' = 'base64',\n  TReturn = TEncode extends 'base64' ? EncryptedString : Uint8Array,\n>(\n  password: BinaryLike,\n  message: BinaryLike,\n  encode: TEncode = 'base64' as TEncode,\n): Promise<TReturn> {\n  // Using randomBytes for the salt is fine here because the salt is not secret but should be unique.\n  const salt = randomBytes(16);\n  const { cipherText, iv } = await encrypt(\n    typeof message === 'string' ? Buffer.from(message) : message,\n    password,\n    salt,\n  );\n\n  const encrypted = Buffer.from(\n    [salt, iv, cipherText]\n      .map((x) => Buffer.from(x).toString('base64'))\n      .join('.'),\n  );\n\n  return (\n    encode === 'base64' ? encrypted.toString('base64') : encrypted\n  ) as TReturn;\n}\n\n/**\n * Decrypts an encrypted message using the provided password.\n * This function is a wrapper for the internal decryption logic, intended\n * for public-facing API usage where the private key encryption follows\n *\n * @param encryptedData - The encrypted data as a Base64 encoded string.\n * @param password - The password used to encrypt the private key.\n * @returns The decrypted private key.\n * @throws Throws an error if decryption fails.\n * @public\n */\nexport async function kadenaDecrypt(\n  password: BinaryLike,\n  encryptedData: BinaryLike,\n): Promise<Uint8Array> {\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  if (!encryptedData) {\n    throw new Error('Encrypted data is empty');\n  }\n  const [saltBase64, ivBase64, encryptedBase64] =\n    typeof encryptedData === 'string'\n      ? Buffer.from(encryptedData, 'base64').toString().split('.')\n      : Buffer.from(encryptedData).toString().split('.');\n\n  // Convert from Base64.\n  const salt = Buffer.from(saltBase64, 'base64');\n  const iv = Buffer.from(ivBase64, 'base64');\n  const cipherText = Buffer.from(encryptedBase64, 'base64');\n\n  // decrypt and return the private key.\n\n  const decrypted = await decrypt({ cipherText, iv }, password, salt).catch(\n    () => undefined,\n  );\n  if (decrypted) return new Uint8Array(decrypted);\n\n  throw new Error('Decryption failed');\n}\n\n/**\n * Changes the password of an encrypted data.\n *\n * @param privateKey - The encrypted private key as a Base64 encoded string.\n * @param password - The current password used to encrypt the private key.\n * @param newPassword - The new password to encrypt the private key with.\n * @returns The newly encrypted private key as a Base64 encoded string.\n * @throws Throws an error if the old password is empty, new password is incorrect empty passwords are empty, or if encryption with the new password fails.\n * @public\n */\nexport async function kadenaChangePassword<\n  TEncode extends 'base64' | 'buffer' = 'base64',\n  TReturn = TEncode extends 'base64' ? EncryptedString : Uint8Array,\n>(\n  password: BinaryLike,\n  encryptedData: BinaryLike,\n  newPassword: string,\n  encode: TEncode = 'base64' as TEncode,\n): Promise<TReturn> {\n  if (typeof password !== 'string' || typeof newPassword !== 'string') {\n    throw new Error('The old and new passwords must be strings.');\n  }\n  if (password === '') {\n    throw new Error('The old password cannot be empty.');\n  }\n  if (newPassword === '') {\n    throw new Error('The new password cannot be empty.');\n  }\n  if (password === newPassword) {\n    throw new Error(\n      'The new password must be different from the old password.',\n    );\n  }\n\n  let decryptedPrivateKey: Uint8Array;\n  try {\n    decryptedPrivateKey = await kadenaDecrypt(password, encryptedData);\n  } catch (error) {\n    throw new Error(\n      `Failed to decrypt the private key with the old password: ${error.message}`,\n    );\n  }\n\n  try {\n    return kadenaEncrypt(newPassword, decryptedPrivateKey, encode);\n  } catch (error) {\n    throw new Error(\n      `Failed to encrypt the private key with the new password: ${error.message}`,\n    );\n  }\n}\n"]}