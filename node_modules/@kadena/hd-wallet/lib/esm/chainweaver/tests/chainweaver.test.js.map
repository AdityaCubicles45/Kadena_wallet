{"version":3,"file":"chainweaver.test.js","sourceRoot":"","sources":["../../../../src/chainweaver/tests/chainweaver.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, expect, it } from 'vitest';\nimport { kadenaDecrypt } from '../../index.js';\nimport { getPublicKeyFromLegacySecretKey } from '../compatibility/encryption.js';\nimport {\n  kadenaCheckMnemonic,\n  kadenaGenKeypair,\n  kadenaGenMnemonic,\n  kadenaMnemonicToRootKeypair,\n  kadenaSign,\n  kadenaSignFromRootKey,\n} from '../index.js';\n\nconst PASSWORD = 'kadena';\nconst MNEMONIC =\n  'mammal east oxygen romance wheel chimney frequent brain spawn owner announce sell';\n\nfunction validateEncryptedValue(value: string) {\n  const buffer = Buffer.from(value, 'base64').toString('utf8');\n  const parts = buffer.split('.');\n  // parts: salt, iv, data\n  return parts.length === 3;\n}\n\nfunction validateEncryptedKeyPair(value: string) {\n  const buffer = Buffer.from(value, 'base64').toString('utf8');\n  const parts = buffer.split('.');\n  // parts: salt, iv, data, public key (only for secretKeys, not rootKey)\n  return parts.length === 4;\n}\n\ndescribe('kadenaGenMnemonic', () => {\n  it('should generate a mnemonic', () => {\n    console.log('kadenaGenMnemonic', kadenaGenMnemonic);\n    const mnemonic = kadenaGenMnemonic();\n    const wordsList = mnemonic.split(' ');\n    expect(wordsList).toHaveLength(12);\n    expect(wordsList.every((word) => word.length > 2)).toBe(true);\n  });\n});\n\ndescribe('kadenaCheckMnemonic', () => {\n  it('should check if a mnemonic is valid', () => {\n    const correctMnemonic = kadenaCheckMnemonic(MNEMONIC);\n    expect(correctMnemonic).toBe(true);\n  });\n  it('should check if a mnemonic is invalid', () => {\n    const WRONG_MNEMONIC =\n      'mammal east oxygen romance wheel chimney frequent brain spawn owner announce';\n    const wrongMnemonic = kadenaCheckMnemonic(WRONG_MNEMONIC);\n    expect(wrongMnemonic).toBe(false);\n  });\n});\n\ndescribe('kadenaMnemonicToRootKeypair', () => {\n  it('should generate a Root key from mnemonic', async () => {\n    const rootKey = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    expect(validateEncryptedValue(rootKey)).toBe(true);\n  });\n\n  it('should generate a the same root key from the same mnemonic', async () => {\n    const rootKey1 = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const rootKey2 = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n\n    const rootKey1Decrypted = kadenaDecrypt(PASSWORD, rootKey1);\n    const rootKey2Decrypted = kadenaDecrypt(PASSWORD, rootKey2);\n\n    expect(rootKey1Decrypted).toEqual(rootKey2Decrypted);\n  });\n\n  it('should generate different root key for different mnemonic', async () => {\n    const mnemonicSecond =\n      'tuna nerve predict all catch early oblige inform hamster magnet century goddess';\n    const rootKey1 = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const rootKey2 = await kadenaMnemonicToRootKeypair(\n      PASSWORD,\n      mnemonicSecond,\n    );\n\n    const rootKey1Decrypted = await kadenaDecrypt(PASSWORD, rootKey1);\n    const rootKey2Decrypted = await kadenaDecrypt(PASSWORD, rootKey2);\n\n    expect(rootKey1Decrypted).not.toEqual(rootKey2Decrypted);\n  });\n\n  it('should generate different root key for different passwords same mnemonic', async () => {\n    // Normally you would expect the same key from the same mnemonic regardless of password\n    // But the rootKey value is encrypted with the password, so it will be different\n    // yes, even after kadenaDecrypt - the legacy code encrypts as well\n    const rootKey1 = await kadenaMnemonicToRootKeypair('pass-one', MNEMONIC);\n    const rootKey2 = await kadenaMnemonicToRootKeypair('pass-two', MNEMONIC);\n\n    const rootKey1Decrypted = await kadenaDecrypt('pass-one', rootKey1);\n    const rootKey2Decrypted = await kadenaDecrypt('pass-two', rootKey2);\n\n    expect(rootKey1Decrypted).not.toEqual(rootKey2Decrypted);\n  });\n});\n\ndescribe('kadenaGenKeypair', () => {\n  it('should generate keyPair from the rootKey', async () => {\n    const rootKey = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const { publicKey, secretKey } = await kadenaGenKeypair(\n      PASSWORD,\n      rootKey,\n      1,\n    );\n    expect(validateEncryptedKeyPair(secretKey)).toBe(true);\n\n    const secretKeyDecrypted = await kadenaDecrypt(PASSWORD, secretKey);\n\n    expect(Buffer.from(secretKeyDecrypted).length).toBe(128);\n    expect(publicKey.length).toBe(64);\n\n    const publicKeyFromSecret = getPublicKeyFromLegacySecretKey(secretKey);\n    expect(publicKeyFromSecret).toEqual(publicKey);\n  });\n\n  it('should generate a range of keypairs from the rootKey', async () => {\n    const rootKey = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const keyPairs = await kadenaGenKeypair(PASSWORD, rootKey, [0, 3]);\n    expect(keyPairs).toHaveLength(4);\n\n    keyPairs.forEach(({ publicKey, secretKey }) => {\n      expect(validateEncryptedKeyPair(secretKey)).toBe(true);\n      expect(publicKey.length).toBe(64);\n    });\n  });\n\n  it('should generate a valid signature', async () => {\n    const rootKey = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const base64hash = 'abc';\n    const signature = await kadenaSignFromRootKey(\n      PASSWORD,\n      base64hash,\n      rootKey,\n      1,\n    );\n\n    expect(signature).toBeTruthy();\n    expect(Buffer.from(signature).toString('hex')).toBe(\n      'bedd0722d330f063266b4b72b2987856c9c7bc0f5f894eb490541441c59bf4c21dba3d35e5214050c90e727b16617c885cb74b2d3fbcd0ebb723f524c8679805',\n    );\n  });\n  it('should generate a valid signature with keypair', async () => {\n    const rootKey = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const keypair = await kadenaGenKeypair(PASSWORD, rootKey, 1);\n    const base64hash = 'abc';\n    const signature = await kadenaSign(PASSWORD, base64hash, keypair.secretKey);\n\n    expect(signature).toBeTruthy();\n    expect(Buffer.from(signature).toString('hex')).toBe(\n      'bedd0722d330f063266b4b72b2987856c9c7bc0f5f894eb490541441c59bf4c21dba3d35e5214050c90e727b16617c885cb74b2d3fbcd0ebb723f524c8679805',\n    );\n  });\n});\n"]}