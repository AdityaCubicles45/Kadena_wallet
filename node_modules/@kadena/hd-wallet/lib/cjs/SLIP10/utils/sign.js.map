{"version":3,"file":"sign.js","sourceRoot":"","sources":["../../../../src/SLIP10/utils/sign.ts"],"names":[],"mappings":";;;AAAA,mEAAsD;AAEtD,gDAA6C;AAC7C,qEAAgE;AAOhE;;;;;;GAMG;AACI,MAAM,aAAa,GAAG,CAC3B,IAAgB,EAChB,cAAsB,EACqB,EAAE;IAC7C,MAAM,GAAG,GAAG,aAAK,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;IAEpE,OAAO;QACL,UAAU,EAAE,IAAA,mCAAe,EAAC,GAAG,CAAC,UAAU,CAAC;QAC3C,SAAS,EAAE,IAAA,mCAAe,EAAC,GAAG,CAAC,SAAS,CAAC;KAC1C,CAAC;AACJ,CAAC,CAAC;AAVW,QAAA,aAAa,iBAUxB;AAEF;;;;;;;;;;;;;GAaG;AACI,MAAM,eAAe,GAC1B,CAAC,SAAiB,EAAE,SAAiB,EAAE,EAAE,CAAC,CAAC,IAAY,EAAE,EAAE;IACzD,MAAM,EAAE,GAAG,EAAE,GAAG,IAAA,6BAAQ,EAAC,IAAI,EAAE,EAAE,SAAS,EAAE,SAAS,EAAE,CAAC,CAAC;IACzD,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;QACtB,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;IAC5C,CAAC;IACD,OAAO,EAAE,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC;AACpC,CAAC,CAAC;AAPS,QAAA,eAAe,mBAOxB;AAEJ;;;;;GAKG;AACI,MAAM,YAAY,GAAG,CAC1B,IAAgB,EAChB,cAAsB,EACuB,EAAE;IAC/C,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,IAAA,qBAAa,EAAC,IAAI,EAAE,cAAc,CAAC,CAAC;IACtE,OAAO,IAAA,uBAAe,EAAC,SAAS,EAAE,UAAU,CAAC,CAAC;AAChD,CAAC,CAAC;AANW,QAAA,YAAY,gBAMvB","sourcesContent":["import { signHash } from '@kadena/cryptography-utils';\n\nimport { HDKey } from 'ed25519-keygen/hdkey';\nimport { uint8ArrayToHex } from '../../utils/buffer-helpers.js';\n\nexport interface ISignatureWithPublicKey {\n  sig: string;\n  pubKey: string;\n}\n\n/**\n * Derive a key pair using a seed and an index. the seed need to be decrypted before using this function.\n * @param seed - The seed for key derivation.\n * @param index - The index for key derivation.\n * @returns Returns the derived private and public keys.\n * @internal\n */\nexport const deriveKeyPair = (\n  seed: Uint8Array,\n  derivationPath: string,\n): { privateKey: string; publicKey: string } => {\n  const key = HDKey.fromMasterSeed(seed).derive(derivationPath, true);\n\n  return {\n    privateKey: uint8ArrayToHex(key.privateKey),\n    publicKey: uint8ArrayToHex(key.publicKey),\n  };\n};\n\n/**\n * Creates a signer function for a given public and secret key pair.\n *\n * @function\n * @param {string} publicKey - The public key for signing.\n * @param {string} [secretKey] - The optional secret key for signing.\n * @returns {Function} A function that takes an unsigned command and returns the command with its signature.\n *\n * @example\n * const signer = signWithKeyPair('myPublicKey', 'mySecretKey');\n * const signedCommand = signer(myUnsignedCommand);\n *\n * @throws {Error} Throws an error if the signature is undefined.\n */\nexport const signWithKeyPair =\n  (publicKey: string, secretKey: string) => (hash: string) => {\n    const { sig } = signHash(hash, { publicKey, secretKey });\n    if (sig === undefined) {\n      throw new Error('Signature is undefined');\n    }\n    return { sig, pubKey: publicKey };\n  };\n\n/**\n * Generate a signer function using a seed and an index.\n * @param {Uint8Array} seed - The seed for key derivation.\n * @param {number} index - The index for key derivation.\n * @returns {(tx: IUnsignedCommand) => { sigs: { sig: string }[] }} - Returns a function that can sign a transaction.\n */\nexport const signWithSeed = (\n  seed: Uint8Array,\n  derivationPath: string,\n): ((hash: string) => ISignatureWithPublicKey) => {\n  const { publicKey, privateKey } = deriveKeyPair(seed, derivationPath);\n  return signWithKeyPair(publicKey, privateKey);\n};\n"]}