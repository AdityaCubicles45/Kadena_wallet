{"version":3,"file":"kadenaSign.js","sourceRoot":"","sources":["../../../src/SLIP10/kadenaSign.ts"],"names":[],"mappings":";;;AAAA,mEAAuD;AAGvD,sEAA6D;AAC7D,+FAAyF;AAEzF,6CAAgE;AAEhE;;;;;;;GAOG;AACH,SAAgB,qBAAqB,CACnC,QAAoB,EACpB,SAAiB,EACjB,mBAAoC;IAEpC,MAAM,mBAAmB,GAAG,IAAA,mCAAa,EAAC,QAAQ,EAAE,mBAAmB,CAAC,CAAC;IACzE,mBAAmB,CAAC,KAAK,CAAC,GAAG,EAAE;QAC7B,OAAO,CAAC,KAAK,CAAC,+BAA+B,CAAC,CAAC;IACjD,CAAC,CAAC,CAAC;IACH,OAAO,KAAK,EAAE,IAAY,EAAE,EAAE,CAC5B,IAAA,yBAAe,EACb,SAAS,EACT,MAAM,CAAC,IAAI,CAAC,MAAM,IAAA,mCAAa,EAAC,QAAQ,EAAE,mBAAmB,CAAC,CAAC,CAAC,QAAQ,CACtE,KAAK,CACN,CACF,CAAC,IAAI,CAAC,CAAC;AACZ,CAAC;AAhBD,sDAgBC;AAgCD;;;;;;GAMG;AACH,SAAgB,kBAAkB,CAChC,QAAoB,EACpB,IAAgB,EAChB,KAAwB,EACxB,yBAAiC,sBAAsB;IAIvD,MAAM,aAAa,GAAG,IAAA,mCAAa,EAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IACpD,aAAa,CAAC,KAAK,CAAC,GAAG,EAAE;QACvB,OAAO,CAAC,KAAK,CAAC,+BAA+B,CAAC,CAAC;IACjD,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,IAAA,gEAA6B,EAAC,sBAAsB,CAAC,EAAE,CAAC;QAC3D,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;IACvD,CAAC;IACD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,OAAO,KAAK,EAAE,IAAY,EAAE,EAAE,CAC5B,IAAA,sBAAY,EACV,MAAM,aAAa,EACnB,sBAAsB,CAAC,OAAO,CAAC,SAAS,EAAE,KAAK,CAAC,QAAQ,EAAE,CAAC,CAC5D,CAAC,IAAI,CAAC,CAAC;IACZ,CAAC;IACD,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CACvB,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,EAAE,IAAY,EAAE,EAAE,CAC5B,IAAA,sBAAY,EACV,MAAM,aAAa,EACnB,sBAAsB,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,CACxD,CAAC,IAAI,CAAC,CACV,CAAC;IAEF,OAAO,CAAC,IAAY,EAAE,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC9E,CAAC;AA/BD,gDA+BC;AAED;;;;;;;;GAQG;AACH,SAAgB,YAAY,CAC1B,OAAmB,EACnB,SAAiB,EACjB,SAAiB;IAEjB,+EAA+E;IAC/E,MAAM,aAAa,GACjB,OAAO,OAAO,KAAK,QAAQ;QACzB,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAC9C,CAAC,CAAC,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC;IAC9B,MAAM,mBAAmB,GAAG,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;IAC3E,MAAM,mBAAmB,GAAG,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;IAE3E,OAAO,IAAA,8BAAS,EAAC,aAAa,EAAE,mBAAmB,EAAE,mBAAmB,CAAC,CAAC;AAC5E,CAAC;AAdD,oCAcC","sourcesContent":["import { verifySig } from '@kadena/cryptography-utils';\nimport type { BinaryLike } from '../utils/crypto.js';\nimport type { EncryptedString } from '../utils/kadenaEncryption.js';\nimport { kadenaDecrypt } from '../utils/kadenaEncryption.js';\nimport { isDerivationPathTemplateValid } from './utils/isDerivationPathTemplateValid.js';\nimport type { ISignatureWithPublicKey } from './utils/sign.js';\nimport { signWithKeyPair, signWithSeed } from './utils/sign.js';\n\n/**\n * Signs a Kadena transaction with a given public and private key pair.\n *\n * @param publicKey - The public key to be used for signing the transaction.\n * @param encryptedPrivateKey - The private key to be used for signing the transaction.\n * @returns A function that takes an unsigned command (`IUnsignedCommand`) and returns an object with an array of signatures.\n * @public\n */\nexport function kadenaSignWithKeyPair(\n  password: BinaryLike,\n  publicKey: string,\n  encryptedPrivateKey: EncryptedString,\n): (hash: string) => Promise<ISignatureWithPublicKey> {\n  const decryptedPrivateKey = kadenaDecrypt(password, encryptedPrivateKey);\n  decryptedPrivateKey.catch(() => {\n    console.error('Could not decrypt private key');\n  });\n  return async (hash: string) =>\n    signWithKeyPair(\n      publicKey,\n      Buffer.from(await kadenaDecrypt(password, encryptedPrivateKey)).toString(\n        'hex',\n      ),\n    )(hash);\n}\n\n/**\n * Signs a Kadena transaction with a seed and index.\n *\n * @param seed - The encrypted seed used to derive key pairs for signing.\n * @param index - The index number used to select the correct key pair from the derived set.\n * @returns A function that takes an unsigned command (`IUnsignedCommand`) and returns an object with an array of signatures.\n * @public\n */\nexport function kadenaSignWithSeed(\n  password: BinaryLike,\n  seed: BinaryLike,\n  index: number,\n  derivationPathTemplate?: string,\n): (hash: string) => Promise<ISignatureWithPublicKey>;\n\n/**\n * Signs a Kadena transaction with a seed and index.\n *\n * @param seed - The encrypted seed used to derive key pairs for signing.\n * @param indexRange - The index range used to select the correct key pair from the derived set.\n * @returns A function that takes an unsigned command (`IUnsignedCommand`) and returns an object with an array of signatures.\n * @public\n */\nexport function kadenaSignWithSeed(\n  password: BinaryLike,\n  seed: BinaryLike,\n  indexRange: number[],\n  derivationPathTemplate?: string,\n): (hash: string) => Promise<ISignatureWithPublicKey[]>;\n\n/**\n * Signs a Kadena transaction with a seed and index.\n *\n * @param seed - The seed array used to derive key pairs for signing.\n * @param index - The index number used to select the correct key pair from the derived set.\n * @returns A function that takes an unsigned command (`IUnsignedCommand`) and returns an object with an array of signatures.\n */\nexport function kadenaSignWithSeed(\n  password: BinaryLike,\n  seed: BinaryLike,\n  index: number | number[],\n  derivationPathTemplate: string = `m'/44'/626'/<index>'`,\n): (\n  hash: string,\n) => Promise<ISignatureWithPublicKey | ISignatureWithPublicKey[]> {\n  const decryptedSeed = kadenaDecrypt(password, seed);\n  decryptedSeed.catch(() => {\n    console.error('Could not decrypt private key');\n  });\n  if (!isDerivationPathTemplateValid(derivationPathTemplate)) {\n    throw new Error('Invalid derivation path template.');\n  }\n  if (typeof index === 'number') {\n    return async (hash: string) =>\n      signWithSeed(\n        await decryptedSeed,\n        derivationPathTemplate.replace('<index>', index.toString()),\n      )(hash);\n  }\n  const signers = index.map(\n    (i) => async (hash: string) =>\n      signWithSeed(\n        await decryptedSeed,\n        derivationPathTemplate.replace('<index>', i.toString()),\n      )(hash),\n  );\n\n  return (hash: string) => Promise.all(signers.map((signer) => signer(hash)));\n}\n\n/**\n * Verifies the signature for a message against a given public key using the Kadena signature verification convention.\n *\n * @param message - The message in string format to be verified.\n * @param publicKey - The public key in hexadecimal string format to verify the signature against.\n * @param signature - The signature in hexadecimal string format to be verified.\n * @returns Returns true if verification succeeded or false if it failed.\n * @public\n */\nexport function kadenaVerify(\n  message: BinaryLike,\n  publicKey: string,\n  signature: string,\n): boolean {\n  // Convert the message, public key, and signature from hex string to Uint8Array\n  const msgUint8Array =\n    typeof message === 'string'\n      ? Uint8Array.from(Buffer.from(message, 'hex'))\n      : new Uint8Array(message);\n  const publicKeyUint8Array = Uint8Array.from(Buffer.from(publicKey, 'hex'));\n  const signatureUint8Array = Uint8Array.from(Buffer.from(signature, 'hex'));\n\n  return verifySig(msgUint8Array, signatureUint8Array, publicKeyUint8Array);\n}\n"]}