{"version":3,"file":"kadenaGetPublic.js","sourceRoot":"","sources":["../../../src/SLIP10/kadenaGetPublic.ts"],"names":[],"mappings":";;;AACA,sEAA6D;AAC7D,+FAAyF;AACzF,6CAAgD;AAEhD,SAAS,oBAAoB,CAC3B,UAAsB,EACtB,KAAa,EACb,sBAA8B;IAE9B,IAAI,CAAC,IAAA,gEAA6B,EAAC,sBAAsB,CAAC,EAAE,CAAC;QAC3D,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;IACvD,CAAC;IAED,MAAM,cAAc,GAAG,sBAAsB,CAAC,OAAO,CACnD,SAAS,EACT,KAAK,CAAC,QAAQ,EAAE,CACjB,CAAC;IAEF,MAAM,EAAE,SAAS,EAAE,GAAG,IAAA,uBAAa,EAAC,UAAU,EAAE,cAAc,CAAC,CAAC;IAEhE,OAAO,SAAS,CAAC;AACnB,CAAC;AAgCD;;;;;;;;;GASG;AACI,KAAK,UAAU,eAAe,CACnC,QAAoB,EACpB,IAAgB,EAChB,YAAuC,EACvC,yBAAiC,sBAAsB;IAEvD,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,EAAE,EAAE,CAAC;QACtC,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;IAChD,CAAC;IAED,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,MAAM,IAAA,mCAAa,EAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;IAEvE,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE,CAAC;QACrC,OAAO,oBAAoB,CACzB,UAAU,EACV,YAAY,EACZ,sBAAsB,CACvB,CAAC;IACJ,CAAC;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE,CAAC;QAChC,MAAM,CAAC,UAAU,EAAE,QAAQ,CAAC,GAAG,YAAY,CAAC;QAC5C,IAAI,UAAU,GAAG,QAAQ,EAAE,CAAC;YAC1B,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;QACtE,CAAC;QAED,MAAM,QAAQ,GAAa,EAAE,CAAC;QAE9B,KAAK,IAAI,KAAK,GAAG,UAAU,EAAE,KAAK,IAAI,QAAQ,EAAE,KAAK,EAAE,EAAE,CAAC;YACxD,MAAM,SAAS,GAAG,oBAAoB,CACpC,UAAU,EACV,KAAK,EACL,sBAAsB,CACvB,CAAC;YAEF,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC3B,CAAC;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;AAC7C,CAAC;AAxCD,0CAwCC","sourcesContent":["import type { BinaryLike } from '../utils/crypto.js';\nimport { kadenaDecrypt } from '../utils/kadenaEncryption.js';\nimport { isDerivationPathTemplateValid } from './utils/isDerivationPathTemplateValid.js';\nimport { deriveKeyPair } from './utils/sign.js';\n\nfunction genPublicKeyFromSeed(\n  seedBuffer: Uint8Array,\n  index: number,\n  derivationPathTemplate: string,\n): string {\n  if (!isDerivationPathTemplateValid(derivationPathTemplate)) {\n    throw new Error('Invalid derivation path template.');\n  }\n\n  const derivationPath = derivationPathTemplate.replace(\n    '<index>',\n    index.toString(),\n  );\n\n  const { publicKey } = deriveKeyPair(seedBuffer, derivationPath);\n\n  return publicKey;\n}\n\n/**\n *\n * @param password - password for decrypting the seed\n * @param seed - encrypted seed to generate keypair\n * @param index - index to generate public key\n * @param derivationPathTemplate - derivation path template\n * @public\n */\nexport function kadenaGetPublic(\n  password: BinaryLike,\n  seed: BinaryLike,\n  index: number,\n  derivationPathTemplate?: string,\n): Promise<string>;\n\n/**\n *\n * @param password - password for decrypting the seed\n * @param seed - encrypted seed to generate keypair\n * @param indexRange - range of indices to generate public keys\n * @param derivationPathTemplate - derivation path template\n * @public\n */\nexport function kadenaGetPublic(\n  password: BinaryLike,\n  seed: BinaryLike,\n  indexRange: [number, number],\n  derivationPathTemplate?: string,\n): Promise<string[]>;\n\n/**\n * Generates a key pair from a seed buffer and an index or range of indices, and optionally encrypts the private key.\n * it uses bip44 m'/44'/626'/${index}' derivation path\n *\n * @param {Uint8Array} seedBuffer - The seed buffer to use for key generation.\n * @param {number | [number, number]} indexOrRange - Either a single index or a tuple with start and end indices for key pair generation.\n * @param {string} [password] - Optional password for encrypting the private key.\n * @returns {([string, string] | [string, string][])} - Depending on the input, either a tuple for a single key pair or an array of tuples for a range of key pairs, with the private key encrypted if a password is provided.\n * @throws {Error} Throws an error if the seed buffer is not provided, if the indices are invalid, or if encryption fails.\n */\nexport async function kadenaGetPublic(\n  password: BinaryLike,\n  seed: BinaryLike,\n  indexOrRange: number | [number, number],\n  derivationPathTemplate: string = `m'/44'/626'/<index>'`,\n): Promise<string | string[]> {\n  if (seed === undefined || seed === '') {\n    throw new Error('NO_SEED: No seed provided.');\n  }\n\n  const seedBuffer = new Uint8Array(await kadenaDecrypt(password, seed));\n\n  if (typeof indexOrRange === 'number') {\n    return genPublicKeyFromSeed(\n      seedBuffer,\n      indexOrRange,\n      derivationPathTemplate,\n    );\n  }\n  if (Array.isArray(indexOrRange)) {\n    const [startIndex, endIndex] = indexOrRange;\n    if (startIndex > endIndex) {\n      throw new Error('The start index must be less than the end index.');\n    }\n\n    const keyPairs: string[] = [];\n\n    for (let index = startIndex; index <= endIndex; index++) {\n      const publicKey = genPublicKeyFromSeed(\n        seedBuffer,\n        index,\n        derivationPathTemplate,\n      );\n\n      keyPairs.push(publicKey);\n    }\n\n    return keyPairs;\n  }\n  throw new Error('Invalid index or range.');\n}\n"]}