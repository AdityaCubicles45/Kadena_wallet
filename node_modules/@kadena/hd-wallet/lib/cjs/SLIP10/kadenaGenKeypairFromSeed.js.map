{"version":3,"file":"kadenaGenKeypairFromSeed.js","sourceRoot":"","sources":["../../../src/SLIP10/kadenaGenKeypairFromSeed.ts"],"names":[],"mappings":";;;AAEA,sEAA4E;AAC5E,+FAAyF;AACzF,6CAAgD;AAEhD,KAAK,UAAU,kBAAkB,CAC/B,QAAoB,EACpB,UAAsB,EACtB,KAAa,EACb,sBAA8B;IAE9B,IAAI,CAAC,IAAA,gEAA6B,EAAC,sBAAsB,CAAC,EAAE,CAAC;QAC3D,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;IACvD,CAAC;IACD,MAAM,cAAc,GAAG,sBAAsB,CAAC,OAAO,CACnD,SAAS,EACT,KAAK,CAAC,QAAQ,EAAE,CACjB,CAAC;IAEF,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,IAAA,uBAAa,EAAC,UAAU,EAAE,cAAc,CAAC,CAAC;IAE5E,MAAM,mBAAmB,GAAG,MAAM,IAAA,mCAAa,EAC7C,QAAQ,EACR,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,CAC/B,CAAC;IAEF,OAAO,CAAC,SAAS,EAAE,mBAAmB,CAAC,CAAC;AAC1C,CAAC;AAgCD;;;;;;;;;GASG;AACI,KAAK,UAAU,wBAAwB,CAC5C,QAAoB,EACpB,IAAqB,EACrB,YAAuC,EACvC,yBAAiC,sBAAsB;IAEvD,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,EAAE,EAAE,CAAC;QACtC,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;IAChD,CAAC;IAED,IAAI,CAAC,IAAA,gEAA6B,EAAC,sBAAsB,CAAC,EAAE,CAAC;QAC3D,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;IACvD,CAAC;IAED,MAAM,UAAU,GAAG,MAAM,IAAA,mCAAa,EAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IAEvD,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE,CAAC;QACrC,OAAO,kBAAkB,CACvB,QAAQ,EACR,UAAU,EACV,YAAY,EACZ,sBAAsB,CACvB,CAAC;IACJ,CAAC;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE,CAAC;QAChC,MAAM,CAAC,UAAU,EAAE,QAAQ,CAAC,GAAG,YAAY,CAAC;QAC5C,IAAI,UAAU,GAAG,QAAQ,EAAE,CAAC;YAC1B,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;QACtE,CAAC;QAED,MAAM,QAAQ,GAAgC,EAAE,CAAC;QAEjD,KAAK,IAAI,KAAK,GAAG,UAAU,EAAE,KAAK,IAAI,QAAQ,EAAE,KAAK,EAAE,EAAE,CAAC;YACxD,MAAM,CAAC,SAAS,EAAE,mBAAmB,CAAC,GAAG,MAAM,kBAAkB,CAC/D,QAAQ,EACR,UAAU,EACV,KAAK,EACL,sBAAsB,CACvB,CAAC;YAEF,QAAQ,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,mBAAmB,CAAC,CAAC,CAAC;QAClD,CAAC;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;AAC7C,CAAC;AA9CD,4DA8CC","sourcesContent":["import type { BinaryLike } from '../utils/crypto.js';\nimport type { EncryptedString } from '../utils/kadenaEncryption.js';\nimport { kadenaDecrypt, kadenaEncrypt } from '../utils/kadenaEncryption.js';\nimport { isDerivationPathTemplateValid } from './utils/isDerivationPathTemplateValid.js';\nimport { deriveKeyPair } from './utils/sign.js';\n\nasync function genKeypairFromSeed(\n  password: BinaryLike,\n  seedBuffer: Uint8Array,\n  index: number,\n  derivationPathTemplate: string,\n): Promise<[string, EncryptedString]> {\n  if (!isDerivationPathTemplateValid(derivationPathTemplate)) {\n    throw new Error('Invalid derivation path template.');\n  }\n  const derivationPath = derivationPathTemplate.replace(\n    '<index>',\n    index.toString(),\n  );\n\n  const { publicKey, privateKey } = deriveKeyPair(seedBuffer, derivationPath);\n\n  const encryptedPrivateKey = await kadenaEncrypt(\n    password,\n    Buffer.from(privateKey, 'hex'),\n  );\n\n  return [publicKey, encryptedPrivateKey];\n}\n\n/**\n *\n * @param password - password for decrypting the seed\n * @param seed - encrypted seed to generate keypair\n * @param index - index to generate keypair\n * @param derivationPathTemplate - derivation path template\n * @public\n */\nexport function kadenaGenKeypairFromSeed(\n  password: BinaryLike,\n  seed: EncryptedString,\n  index: number,\n  derivationPathTemplate?: string,\n): Promise<[string, EncryptedString]>;\n\n/**\n *\n * @param password - password for decrypting the seed\n * @param seed - encrypted seed to generate keypair\n * @param indexRange - range of indices to generate keypair\n * @param derivationPathTemplate - derivation path template\n * @public\n */\nexport function kadenaGenKeypairFromSeed(\n  password: BinaryLike,\n  seed: EncryptedString,\n  indexRange: [number, number],\n  derivationPathTemplate?: string,\n): Promise<Array<[string, EncryptedString]>>;\n\n/**\n * Generates a key pair from a seed buffer and an index or range of indices, and optionally encrypts the private key.\n * it uses bip44 m'/44'/626'/${index}' derivation path\n *\n * @param {Uint8Array} seedBuffer - The seed buffer to use for key generation.\n * @param {number | [number, number]} indexOrRange - Either a single index or a tuple with start and end indices for key pair generation.\n * @param {string} [password] - Optional password for encrypting the private key.\n * @returns {([string, string] | [string, string][])} - Depending on the input, either a tuple for a single key pair or an array of tuples for a range of key pairs, with the private key encrypted if a password is provided.\n * @throws {Error} Throws an error if the seed buffer is not provided, if the indices are invalid, or if encryption fails.\n */\nexport async function kadenaGenKeypairFromSeed(\n  password: BinaryLike,\n  seed: EncryptedString,\n  indexOrRange: number | [number, number],\n  derivationPathTemplate: string = `m'/44'/626'/<index>'`,\n): Promise<[string, EncryptedString] | Array<[string, EncryptedString]>> {\n  if (seed === undefined || seed === '') {\n    throw new Error('NO_SEED: No seed provided.');\n  }\n\n  if (!isDerivationPathTemplateValid(derivationPathTemplate)) {\n    throw new Error('Invalid derivation path template.');\n  }\n\n  const seedBuffer = await kadenaDecrypt(password, seed);\n\n  if (typeof indexOrRange === 'number') {\n    return genKeypairFromSeed(\n      password,\n      seedBuffer,\n      indexOrRange,\n      derivationPathTemplate,\n    );\n  }\n  if (Array.isArray(indexOrRange)) {\n    const [startIndex, endIndex] = indexOrRange;\n    if (startIndex > endIndex) {\n      throw new Error('The start index must be less than the end index.');\n    }\n\n    const keyPairs: [string, EncryptedString][] = [];\n\n    for (let index = startIndex; index <= endIndex; index++) {\n      const [publicKey, encryptedPrivateKey] = await genKeypairFromSeed(\n        password,\n        seedBuffer,\n        index,\n        derivationPathTemplate,\n      );\n\n      keyPairs.push([publicKey, encryptedPrivateKey]);\n    }\n\n    return keyPairs;\n  }\n  throw new Error('Invalid index or range.');\n}\n"]}