"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const index_js_1 = require("../index.js");
const kadenaEncryption_js_1 = require("../../utils/kadenaEncryption.js");
(0, vitest_1.describe)('kadenaGenKeypairFromSeed', () => {
    (0, vitest_1.it)('should generate an encrypted keypair from the seedBuffer when a password is provided', async () => {
        const mnemonic = (0, index_js_1.kadenaGenMnemonic)();
        const password = 'password';
        const seed = await (0, index_js_1.kadenaMnemonicToSeed)(password, mnemonic);
        const [publicKey, encryptedPrivateKey] = await (0, index_js_1.kadenaGenKeypairFromSeed)(password, seed, 0);
        (0, vitest_1.expect)(publicKey).toHaveLength(64);
        (0, vitest_1.expect)(typeof encryptedPrivateKey).toBe('string'); // Checks if privateKey is a string, thus encrypted
    });
    (0, vitest_1.it)('should generate a range of keypairs from the seed', async () => {
        const mnemonic = (0, index_js_1.kadenaGenMnemonic)();
        const password = 'password';
        const seed = await (0, index_js_1.kadenaMnemonicToSeed)(password, mnemonic);
        const keyPairs = await (0, index_js_1.kadenaGenKeypairFromSeed)(password, seed, [0, 3]);
        (0, vitest_1.expect)(keyPairs).toHaveLength(4);
        await Promise.all(keyPairs.map(async ([publicKey, privateKey]) => {
            (0, vitest_1.expect)(publicKey).toHaveLength(64);
            (0, vitest_1.expect)(Buffer.from(await (0, kadenaEncryption_js_1.kadenaDecrypt)(password, privateKey)).toString('hex')).toHaveLength(64);
        }));
    });
    (0, vitest_1.it)('should throw an error for out-of-bounds index values', async () => {
        const mnemonic = (0, index_js_1.kadenaGenMnemonic)();
        const password = 'password';
        const seed = await (0, index_js_1.kadenaMnemonicToSeed)(password, mnemonic);
        const outOfBoundsIndex = -1;
        await (0, vitest_1.expect)(() => (0, index_js_1.kadenaGenKeypairFromSeed)(password, seed, outOfBoundsIndex)).rejects.toThrowError('Invalid child index: -1');
    });
    (0, vitest_1.it)('returns an encrypted private key that can be decrypted with the password', async () => {
        const mnemonic = (0, index_js_1.kadenaGenMnemonic)();
        const password = 'password';
        const seed = await (0, index_js_1.kadenaMnemonicToSeed)(password, mnemonic);
        const [, encryptedPrivateKey] = await (0, index_js_1.kadenaGenKeypairFromSeed)(password, seed, 0);
        const decryptedPrivateKey = await (0, kadenaEncryption_js_1.kadenaDecrypt)(password, encryptedPrivateKey);
        (0, vitest_1.expect)(decryptedPrivateKey).toBeTruthy();
        (0, vitest_1.expect)(Buffer.from(decryptedPrivateKey).toString('hex')).toHaveLength(64);
    });
    //   it('should handle the highest non-hardened index without throwing errors', async () => {
    //     const mnemonic = kadenaGenMnemonic();
    //     const { seedBuffer } = await kadenaMnemonicToSeed(mnemonic);
    //     /*
    //      * HD wallets as per BIP32 spec define two types of indices:
    //      * - Non-hardened (ranging from 0 to 2^31 - 1)
    //      * - Hardened (ranging from 2^31 to 2^32 - 1).
    //      * The highest non-hardened index is therefore 2^31 - 1,
    //      * which is the largest 32-bit integer that can be used for generating non-hardened keys.
    //      */
    //     const highestNonHardenedIndex = 2 ** 31 - 1;
    //     expect(() => {
    //       kadenaGenKeypairFromSeed(seedBuffer, highestNonHardenedIndex);
    //     }).not.toThrow();
    //   });
});
//# sourceMappingURL=kadenaGenKeypairFromSeed.test.js.map