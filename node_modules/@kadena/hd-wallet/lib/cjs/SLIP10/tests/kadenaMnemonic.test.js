"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const index_js_1 = require("../index.js");
const kadenaEncryption_js_1 = require("../../utils/kadenaEncryption.js");
(0, vitest_1.describe)('kadenaGenMnemonic', () => {
    (0, vitest_1.it)('should generate a valid mnemonic', () => {
        const mnemonic = (0, index_js_1.kadenaGenMnemonic)();
        (0, vitest_1.expect)(mnemonic.split(' ')).toHaveLength(12);
    });
});
(0, vitest_1.describe)('kadenaMnemonicToSeed', () => {
    (0, vitest_1.it)('should convert mnemonic to encrypt seed with a password', async () => {
        const mnemonic = (0, index_js_1.kadenaGenMnemonic)();
        const password = 'password';
        const seed = await (0, index_js_1.kadenaMnemonicToSeed)(password, mnemonic);
        (0, vitest_1.expect)(typeof seed).toBe('string'); // Check if the seed is a string, indicating it has been encrypted
    });
    (0, vitest_1.it)('returns encrypted seed that can be decrypted with the password', async () => {
        const mnemonic = (0, index_js_1.kadenaGenMnemonic)();
        const password = 'password';
        const seed = await (0, index_js_1.kadenaMnemonicToSeed)(password, mnemonic);
        const decryptedSeed = (0, kadenaEncryption_js_1.kadenaDecrypt)(password, seed);
        (0, vitest_1.expect)(decryptedSeed).toBeTruthy();
    });
    (0, vitest_1.it)('should throw an error for an invalid mnemonic', async () => {
        const invalidMnemonic = 'this is not a valid mnemonic';
        await (0, vitest_1.expect)((0, index_js_1.kadenaMnemonicToSeed)('password', invalidMnemonic)).rejects.toThrowError('Invalid mnemonic.');
    });
    (0, vitest_1.it)('should throw an error when mnemonic is empty', async () => {
        const emptyMnemonic = '';
        await (0, vitest_1.expect)((0, index_js_1.kadenaMnemonicToSeed)('password', emptyMnemonic)).rejects.toThrowError('Invalid mnemonic.');
    });
});
//# sourceMappingURL=kadenaMnemonic.test.js.map