{"version":3,"file":"kadenaGenKeypair.js","sourceRoot":"","sources":["../../../../src/chainweaver/compatibility/kadenaGenKeypair.ts"],"names":[],"mappings":";;;AACA,6CAA+C;AAC/C,0DAAmF;AACnF,mDAAyD;AAEzD,MAAM,eAAe,GAAG,UAAU,CAAC;AACnC,MAAM,MAAM,GAAG,CAAC,CAAS,EAAE,EAAE,CAAC,eAAe,GAAG,CAAC,CAAC;AAElD,KAAK,UAAU,mBAAmB,CAChC,QAA6B,EAC7B,OAAmB,EACnB,KAAa;IAEb,IAAI,KAAK,GAAG,eAAe,EAAE,CAAC;QAC5B,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;IAC5C,CAAC;IACD,MAAM,OAAO,GAAG,MAAM,IAAA,mCAAwB,EAAC,QAAQ,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;IACzE,OAAO;QACL,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC;QAClD,SAAS,EAAE,MAAM,IAAA,sCAAsB,EAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;KAC9D,CAAC;AACJ,CAAC;AA0BM,KAAK,UAAU,gBAAgB,CACpC,QAA6B,EAC7B,OAAqC,EACrC,YAAmD;IAEnD,MAAM,SAAS,GAAG,MAAM,IAAA,wBAAa,EAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IACzD,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE,CAAC;QACrC,OAAO,MAAM,mBAAmB,CAAC,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC;IAC9E,CAAC;IACD,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,YAAY,CAAC;IAClC,MAAM,QAAQ,GAAG,EAAE,CAAC;IACpB,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QACrC,QAAQ,CAAC,IAAI,CAAC,MAAM,mBAAmB,CAAC,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3E,CAAC;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAfD,4CAeC","sourcesContent":["import type { EncryptedString } from '../../index.js';\nimport { kadenaDecrypt } from '../../index.js';\nimport { kadenaGenKeypair as kadenaGenKeypairOriginal } from '../kadena-crypto.js';\nimport { encryptLegacySecretKey } from './encryption.js';\n\nconst HARDENED_OFFSET = 0x80000000;\nconst harden = (n: number) => HARDENED_OFFSET + n;\n\nasync function kadenaGenOneKeypair(\n  password: string | Uint8Array,\n  rootKey: Uint8Array,\n  index: number,\n): Promise<{ publicKey: string; secretKey: EncryptedString }> {\n  if (index < HARDENED_OFFSET) {\n    throw new Error('Index must be hardened');\n  }\n  const keyPair = await kadenaGenKeypairOriginal(password, rootKey, index);\n  return {\n    publicKey: Buffer.from(keyPair[1]).toString('hex'),\n    secretKey: await encryptLegacySecretKey(password, keyPair[0]),\n  };\n}\n\n/**\n *\n * @param password\n * @param rootKey\n * @param index start from 0; it will be hardened automatically\n */\nexport function kadenaGenKeypair(\n  password: string | Uint8Array,\n  rootKey: EncryptedString | Uint8Array,\n  index: number,\n): Promise<{ publicKey: string; secretKey: EncryptedString }>;\n\n/**\n *\n * @param password\n * @param rootKey\n * @param range [start, end] start from 0; it will be hardened automatically\n */\nexport function kadenaGenKeypair(\n  password: string | Uint8Array,\n  rootKey: EncryptedString | Uint8Array,\n  range: [start: number, end: number],\n): Promise<{ publicKey: string; secretKey: EncryptedString }[]>;\n\nexport async function kadenaGenKeypair(\n  password: string | Uint8Array,\n  rootKey: EncryptedString | Uint8Array,\n  indexOrRange: number | [start: number, end: number],\n) {\n  const decrypted = await kadenaDecrypt(password, rootKey);\n  if (typeof indexOrRange === 'number') {\n    return await kadenaGenOneKeypair(password, decrypted, harden(indexOrRange));\n  }\n  const [start, end] = indexOrRange;\n  const keypairs = [];\n  for (let i = start; i <= end; i += 1) {\n    keypairs.push(await kadenaGenOneKeypair(password, decrypted, harden(i)));\n  }\n  return keypairs;\n}\n"]}