{"version":3,"file":"chainweaver.test.js","sourceRoot":"","sources":["../../../../src/chainweaver/tests/chainweaver.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, expect, it } from 'vitest';\nimport { kadenaDecrypt } from '../../index.js';\nimport { getPublicKeyFromLegacySecretKey } from '../compatibility/encryption.js';\nimport {\n  kadenaCheckMnemonic,\n  kadenaGenKeypair,\n  kadenaGenMnemonic,\n  kadenaMnemonicToRootKeypair,\n  kadenaSign,\n  kadenaSignFromRootKey,\n} from '../index.js';\n\nconst PASSWORD = 'kadena';\nconst MNEMONIC =\n  'mammal east oxygen romance wheel chimney frequent brain spawn owner announce sell';\n\nfunction validateEncryptedValue(value: string) {\n  const buffer = Buffer.from(value, 'base64').toString('utf8');\n  const parts = buffer.split('.');\n  // parts: salt, iv, data\n  return parts.length === 3;\n}\n\nfunction validateEncryptedKeyPair(value: string) {\n  const buffer = Buffer.from(value, 'base64').toString('utf8');\n  const parts = buffer.split('.');\n  // parts: salt, iv, data, public key (only for secretKeys, not rootKey)\n  return parts.length === 4;\n}\n\ndescribe('kadenaGenMnemonic', () => {\n  it('should generate a mnemonic', () => {\n    console.log('kadenaGenMnemonic', kadenaGenMnemonic);\n    const mnemonic = kadenaGenMnemonic();\n    const wordsList = mnemonic.split(' ');\n    expect(wordsList).toHaveLength(12);\n    expect(wordsList.every((word) => word.length > 2)).toBe(true);\n  });\n});\n\ndescribe('kadenaCheckMnemonic', () => {\n  it('should check if a mnemonic is valid', () => {\n    const correctMnemonic = kadenaCheckMnemonic(MNEMONIC);\n    expect(correctMnemonic).toBe(true);\n  });\n  it('should check if a mnemonic is invalid', () => {\n    const WRONG_MNEMONIC =\n      'mammal east oxygen romance wheel chimney frequent brain spawn owner announce';\n    const wrongMnemonic = kadenaCheckMnemonic(WRONG_MNEMONIC);\n    expect(wrongMnemonic).toBe(false);\n  });\n});\n\ndescribe('kadenaMnemonicToRootKeypair', () => {\n  it('should generate a Root key from mnemonic', async () => {\n    const rootKey = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    expect(validateEncryptedValue(rootKey)).toBe(true);\n  });\n\n  it('should generate a the same root key from the same mnemonic', async () => {\n    const rootKey1 = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const rootKey2 = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n\n    const rootKey1Decrypted = kadenaDecrypt(PASSWORD, rootKey1);\n    const rootKey2Decrypted = kadenaDecrypt(PASSWORD, rootKey2);\n\n    expect(rootKey1Decrypted).toEqual(rootKey2Decrypted);\n  });\n\n  it('should generate different root key for different mnemonic', async () => {\n    const mnemonicSecond =\n      'tuna nerve predict all catch early oblige inform hamster magnet century goddess';\n    const rootKey1 = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const rootKey2 = await kadenaMnemonicToRootKeypair(\n      PASSWORD,\n      mnemonicSecond,\n    );\n\n    const rootKey1Decrypted = await kadenaDecrypt(PASSWORD, rootKey1);\n    const rootKey2Decrypted = await kadenaDecrypt(PASSWORD, rootKey2);\n\n    expect(rootKey1Decrypted).not.toEqual(rootKey2Decrypted);\n  });\n\n  it('should generate different root key for different passwords same mnemonic', async () => {\n    // Normally you would expect the same key from the same mnemonic regardless of password\n    // But the rootKey value is encrypted with the password, so it will be different\n    // yes, even after kadenaDecrypt - the legacy code encrypts as well\n    const rootKey1 = await kadenaMnemonicToRootKeypair('pass-one', MNEMONIC);\n    const rootKey2 = await kadenaMnemonicToRootKeypair('pass-two', MNEMONIC);\n\n    const rootKey1Decrypted = await kadenaDecrypt('pass-one', rootKey1);\n    const rootKey2Decrypted = await kadenaDecrypt('pass-two', rootKey2);\n\n    expect(rootKey1Decrypted).not.toEqual(rootKey2Decrypted);\n  });\n});\n\ndescribe('kadenaGenKeypair', () => {\n  it('should generate keyPair from the rootKey', async () => {\n    const rootKey = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const { publicKey, secretKey } = await kadenaGenKeypair(\n      PASSWORD,\n      rootKey,\n      1,\n    );\n    expect(validateEncryptedKeyPair(secretKey)).toBe(true);\n\n    const secretKeyDecrypted = await kadenaDecrypt(PASSWORD, secretKey);\n\n    expect(Buffer.from(secretKeyDecrypted).length).toBe(128);\n    expect(publicKey.length).toBe(64);\n\n    const publicKeyFromSecret = getPublicKeyFromLegacySecretKey(secretKey);\n    expect(publicKeyFromSecret).toEqual(publicKey);\n  });\n\n  it('should generate a range of keypairs from the rootKey', async () => {\n    const rootKey = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const keyPairs = await kadenaGenKeypair(PASSWORD, rootKey, [0, 3]);\n    expect(keyPairs).toHaveLength(4);\n\n    keyPairs.forEach(({ publicKey, secretKey }) => {\n      expect(validateEncryptedKeyPair(secretKey)).toBe(true);\n      expect(publicKey.length).toBe(64);\n    });\n  });\n\n  it('should generate a valid signature', async () => {\n    const rootKey = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const base64hash = 'abc';\n    const signature = await kadenaSignFromRootKey(\n      PASSWORD,\n      base64hash,\n      rootKey,\n      1,\n    );\n\n    expect(signature).toBeTruthy();\n    expect(Buffer.from(signature).toString('hex')).toBe(\n      'bedd0722d330f063266b4b72b2987856c9c7bc0f5f894eb490541441c59bf4c21dba3d35e5214050c90e727b16617c885cb74b2d3fbcd0ebb723f524c8679805',\n    );\n  });\n  it('should generate a valid signature with keypair', async () => {\n    const rootKey = await kadenaMnemonicToRootKeypair(PASSWORD, MNEMONIC);\n    const keypair = await kadenaGenKeypair(PASSWORD, rootKey, 1);\n    const base64hash = 'abc';\n    const signature = await kadenaSign(PASSWORD, base64hash, keypair.secretKey);\n\n    expect(signature).toBeTruthy();\n    expect(Buffer.from(signature).toString('hex')).toBe(\n      'bedd0722d330f063266b4b72b2987856c9c7bc0f5f894eb490541441c59bf4c21dba3d35e5214050c90e727b16617c885cb74b2d3fbcd0ebb723f524c8679805',\n    );\n  });\n});\n"]}