"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const index_js_1 = require("../../index.js");
const encryption_js_1 = require("../compatibility/encryption.js");
const index_js_2 = require("../index.js");
const PASSWORD = 'kadena';
const MNEMONIC = 'mammal east oxygen romance wheel chimney frequent brain spawn owner announce sell';
function validateEncryptedValue(value) {
    const buffer = Buffer.from(value, 'base64').toString('utf8');
    const parts = buffer.split('.');
    // parts: salt, iv, data
    return parts.length === 3;
}
function validateEncryptedKeyPair(value) {
    const buffer = Buffer.from(value, 'base64').toString('utf8');
    const parts = buffer.split('.');
    // parts: salt, iv, data, public key (only for secretKeys, not rootKey)
    return parts.length === 4;
}
(0, vitest_1.describe)('kadenaGenMnemonic', () => {
    (0, vitest_1.it)('should generate a mnemonic', () => {
        console.log('kadenaGenMnemonic', index_js_2.kadenaGenMnemonic);
        const mnemonic = (0, index_js_2.kadenaGenMnemonic)();
        const wordsList = mnemonic.split(' ');
        (0, vitest_1.expect)(wordsList).toHaveLength(12);
        (0, vitest_1.expect)(wordsList.every((word) => word.length > 2)).toBe(true);
    });
});
(0, vitest_1.describe)('kadenaCheckMnemonic', () => {
    (0, vitest_1.it)('should check if a mnemonic is valid', () => {
        const correctMnemonic = (0, index_js_2.kadenaCheckMnemonic)(MNEMONIC);
        (0, vitest_1.expect)(correctMnemonic).toBe(true);
    });
    (0, vitest_1.it)('should check if a mnemonic is invalid', () => {
        const WRONG_MNEMONIC = 'mammal east oxygen romance wheel chimney frequent brain spawn owner announce';
        const wrongMnemonic = (0, index_js_2.kadenaCheckMnemonic)(WRONG_MNEMONIC);
        (0, vitest_1.expect)(wrongMnemonic).toBe(false);
    });
});
(0, vitest_1.describe)('kadenaMnemonicToRootKeypair', () => {
    (0, vitest_1.it)('should generate a Root key from mnemonic', async () => {
        const rootKey = await (0, index_js_2.kadenaMnemonicToRootKeypair)(PASSWORD, MNEMONIC);
        (0, vitest_1.expect)(validateEncryptedValue(rootKey)).toBe(true);
    });
    (0, vitest_1.it)('should generate a the same root key from the same mnemonic', async () => {
        const rootKey1 = await (0, index_js_2.kadenaMnemonicToRootKeypair)(PASSWORD, MNEMONIC);
        const rootKey2 = await (0, index_js_2.kadenaMnemonicToRootKeypair)(PASSWORD, MNEMONIC);
        const rootKey1Decrypted = (0, index_js_1.kadenaDecrypt)(PASSWORD, rootKey1);
        const rootKey2Decrypted = (0, index_js_1.kadenaDecrypt)(PASSWORD, rootKey2);
        (0, vitest_1.expect)(rootKey1Decrypted).toEqual(rootKey2Decrypted);
    });
    (0, vitest_1.it)('should generate different root key for different mnemonic', async () => {
        const mnemonicSecond = 'tuna nerve predict all catch early oblige inform hamster magnet century goddess';
        const rootKey1 = await (0, index_js_2.kadenaMnemonicToRootKeypair)(PASSWORD, MNEMONIC);
        const rootKey2 = await (0, index_js_2.kadenaMnemonicToRootKeypair)(PASSWORD, mnemonicSecond);
        const rootKey1Decrypted = await (0, index_js_1.kadenaDecrypt)(PASSWORD, rootKey1);
        const rootKey2Decrypted = await (0, index_js_1.kadenaDecrypt)(PASSWORD, rootKey2);
        (0, vitest_1.expect)(rootKey1Decrypted).not.toEqual(rootKey2Decrypted);
    });
    (0, vitest_1.it)('should generate different root key for different passwords same mnemonic', async () => {
        // Normally you would expect the same key from the same mnemonic regardless of password
        // But the rootKey value is encrypted with the password, so it will be different
        // yes, even after kadenaDecrypt - the legacy code encrypts as well
        const rootKey1 = await (0, index_js_2.kadenaMnemonicToRootKeypair)('pass-one', MNEMONIC);
        const rootKey2 = await (0, index_js_2.kadenaMnemonicToRootKeypair)('pass-two', MNEMONIC);
        const rootKey1Decrypted = await (0, index_js_1.kadenaDecrypt)('pass-one', rootKey1);
        const rootKey2Decrypted = await (0, index_js_1.kadenaDecrypt)('pass-two', rootKey2);
        (0, vitest_1.expect)(rootKey1Decrypted).not.toEqual(rootKey2Decrypted);
    });
});
(0, vitest_1.describe)('kadenaGenKeypair', () => {
    (0, vitest_1.it)('should generate keyPair from the rootKey', async () => {
        const rootKey = await (0, index_js_2.kadenaMnemonicToRootKeypair)(PASSWORD, MNEMONIC);
        const { publicKey, secretKey } = await (0, index_js_2.kadenaGenKeypair)(PASSWORD, rootKey, 1);
        (0, vitest_1.expect)(validateEncryptedKeyPair(secretKey)).toBe(true);
        const secretKeyDecrypted = await (0, index_js_1.kadenaDecrypt)(PASSWORD, secretKey);
        (0, vitest_1.expect)(Buffer.from(secretKeyDecrypted).length).toBe(128);
        (0, vitest_1.expect)(publicKey.length).toBe(64);
        const publicKeyFromSecret = (0, encryption_js_1.getPublicKeyFromLegacySecretKey)(secretKey);
        (0, vitest_1.expect)(publicKeyFromSecret).toEqual(publicKey);
    });
    (0, vitest_1.it)('should generate a range of keypairs from the rootKey', async () => {
        const rootKey = await (0, index_js_2.kadenaMnemonicToRootKeypair)(PASSWORD, MNEMONIC);
        const keyPairs = await (0, index_js_2.kadenaGenKeypair)(PASSWORD, rootKey, [0, 3]);
        (0, vitest_1.expect)(keyPairs).toHaveLength(4);
        keyPairs.forEach(({ publicKey, secretKey }) => {
            (0, vitest_1.expect)(validateEncryptedKeyPair(secretKey)).toBe(true);
            (0, vitest_1.expect)(publicKey.length).toBe(64);
        });
    });
    (0, vitest_1.it)('should generate a valid signature', async () => {
        const rootKey = await (0, index_js_2.kadenaMnemonicToRootKeypair)(PASSWORD, MNEMONIC);
        const base64hash = 'abc';
        const signature = await (0, index_js_2.kadenaSignFromRootKey)(PASSWORD, base64hash, rootKey, 1);
        (0, vitest_1.expect)(signature).toBeTruthy();
        (0, vitest_1.expect)(Buffer.from(signature).toString('hex')).toBe('bedd0722d330f063266b4b72b2987856c9c7bc0f5f894eb490541441c59bf4c21dba3d35e5214050c90e727b16617c885cb74b2d3fbcd0ebb723f524c8679805');
    });
    (0, vitest_1.it)('should generate a valid signature with keypair', async () => {
        const rootKey = await (0, index_js_2.kadenaMnemonicToRootKeypair)(PASSWORD, MNEMONIC);
        const keypair = await (0, index_js_2.kadenaGenKeypair)(PASSWORD, rootKey, 1);
        const base64hash = 'abc';
        const signature = await (0, index_js_2.kadenaSign)(PASSWORD, base64hash, keypair.secretKey);
        (0, vitest_1.expect)(signature).toBeTruthy();
        (0, vitest_1.expect)(Buffer.from(signature).toString('hex')).toBe('bedd0722d330f063266b4b72b2987856c9c7bc0f5f894eb490541441c59bf4c21dba3d35e5214050c90e727b16617c885cb74b2d3fbcd0ebb723f524c8679805');
    });
});
//# sourceMappingURL=chainweaver.test.js.map