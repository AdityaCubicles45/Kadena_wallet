"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decrypt = exports.encrypt = exports.randomBytes = void 0;
/**
 *
 * @param size - size of random bytes
 * @returns Uint8Array of random bytes
 * @public
 */
const randomBytes = (size) => crypto.getRandomValues(new Uint8Array(size));
exports.randomBytes = randomBytes;
// derive string key
async function deriveKey(password, salt) {
    const algo = {
        name: 'PBKDF2',
        hash: 'SHA-256',
        salt: typeof salt === 'string' ? new TextEncoder().encode(salt) : salt,
        iterations: 1000,
    };
    return crypto.subtle.deriveKey(algo, await crypto.subtle.importKey('raw', typeof password === 'string'
        ? new TextEncoder().encode(password)
        : password, {
        name: algo.name,
    }, false, ['deriveKey']), {
        name: 'AES-GCM',
        length: 256,
    }, false, ['encrypt', 'decrypt']);
}
// Encrypt function
async function encrypt(text, password, salt) {
    const algo = {
        name: 'AES-GCM',
        length: 256,
        iv: (0, exports.randomBytes)(12),
    };
    return {
        cipherText: new Uint8Array(await crypto.subtle.encrypt(algo, await deriveKey(password, salt), 
        //   new TextEncoder().encode(text)
        typeof text === 'string' ? new TextEncoder().encode(text) : text)),
        iv: algo.iv,
    };
}
exports.encrypt = encrypt;
// Decrypt function
async function decrypt(encrypted, password, salt) {
    const algo = {
        name: 'AES-GCM',
        length: 256,
        iv: encrypted.iv,
    };
    return new Uint8Array(await crypto.subtle.decrypt(algo, await deriveKey(password, salt), encrypted.cipherText));
}
exports.decrypt = decrypt;
//# sourceMappingURL=crypto.js.map