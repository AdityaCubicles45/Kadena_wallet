"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const kadenaEncryption_js_1 = require("../kadenaEncryption.js");
(0, vitest_1.describe)('kadenaDecrypt', () => {
    (0, vitest_1.it)('should correctly decrypt a previously encrypted string', async () => {
        const password = 'test-password';
        const message = Buffer.from('test-message');
        const encryptedMessage = await (0, kadenaEncryption_js_1.kadenaEncrypt)(password, message);
        const decryptedMessage = await (0, kadenaEncryption_js_1.kadenaDecrypt)(password, encryptedMessage);
        (0, vitest_1.expect)(Buffer.from(decryptedMessage).toString('utf-8')).toEqual(message.toString('utf-8'));
        (0, vitest_1.expect)(message.toString()).not.toBe(encryptedMessage);
        (0, vitest_1.expect)(encryptedMessage).not.toBe(Buffer.from(decryptedMessage).toString());
    });
    (0, vitest_1.it)('should throw an error when the incorrect password is provided', async () => {
        const correctPassword = 'correct-password';
        const wrongPassword = 'wrong-password';
        const message = Buffer.from('test-message');
        const encryptedMessage = await (0, kadenaEncryption_js_1.kadenaEncrypt)(correctPassword, message);
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaDecrypt)(wrongPassword, encryptedMessage)).rejects.toThrow('Decryption failed');
    });
    (0, vitest_1.it)('should throw an error if the encrypted key is corrupted', async () => {
        const password = 'test-password';
        const corruptedEncryptedPrivateKey = 'corrupted-data';
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaDecrypt)(password, corruptedEncryptedPrivateKey)).rejects.toThrow();
    });
    (0, vitest_1.it)('should throw an error if the encrypted data is empty', async () => {
        const password = 'test-password';
        const emptyEncryptedMessage = '';
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaDecrypt)(password, emptyEncryptedMessage)).rejects.toThrow('Encrypted data is empty');
    });
    (0, vitest_1.it)('should handle passwords with special characters', async () => {
        const specialCharPassword = 'p@ssw0rd!#%&';
        const message = Buffer.from('test-message');
        const encryptedMessage = await (0, kadenaEncryption_js_1.kadenaEncrypt)(specialCharPassword, message);
        const decryptedMessage = await (0, kadenaEncryption_js_1.kadenaDecrypt)(specialCharPassword, encryptedMessage);
        (0, vitest_1.expect)(Buffer.from(decryptedMessage).toString()).toBe(message.toString());
    });
    (0, vitest_1.it)('should handle extremely long passwords', async () => {
        const longPassword = 'p'.repeat(1000);
        const message = Buffer.from('test-message');
        const encryptedMessage = await (0, kadenaEncryption_js_1.kadenaEncrypt)(longPassword, message);
        const decryptedMessage = await (0, kadenaEncryption_js_1.kadenaDecrypt)(longPassword, encryptedMessage);
        (0, vitest_1.expect)(Buffer.from(decryptedMessage).toString()).toBe(message.toString());
    });
    (0, vitest_1.it)('should handle unicode characters in passwords', async () => {
        const unicodePassword = '密码'; // 'password' in Chinese
        const message = Buffer.from('test-message');
        const encryptedMessage = await (0, kadenaEncryption_js_1.kadenaEncrypt)(unicodePassword, message);
        const decryptedMessage = await (0, kadenaEncryption_js_1.kadenaDecrypt)(unicodePassword, encryptedMessage);
        (0, vitest_1.expect)(Buffer.from(decryptedMessage).toString()).toBe(message.toString());
    });
});
(0, vitest_1.describe)('kadenaChangePassword', () => {
    const privateKey = Uint8Array.from({ length: 32 }, () => Math.floor(Math.random() * 256));
    const password = 'currentPassword123';
    const newPassword = 'newPassword123';
    (0, vitest_1.it)('changes the password successfully and allows decryption with the new password', async () => {
        const firstPassword = 'firstPassword123';
        const secondPassword = 'secondPassword123';
        const message = Buffer.from('test-message');
        const encryptedMessage = await (0, kadenaEncryption_js_1.kadenaEncrypt)(firstPassword, message);
        const newEncryptedMessage = await (0, kadenaEncryption_js_1.kadenaChangePassword)(firstPassword, encryptedMessage, secondPassword);
        (0, vitest_1.expect)(encryptedMessage.toString()).not.toBe(newEncryptedMessage.toString());
        const decryptedMessage = Buffer.from(await (0, kadenaEncryption_js_1.kadenaDecrypt)(secondPassword, newEncryptedMessage));
        (0, vitest_1.expect)(decryptedMessage.toString()).toBe(message.toString());
    });
    (0, vitest_1.it)('throws an error when the password is incorrect', async () => {
        const encryptedPrivateKey = await (0, kadenaEncryption_js_1.kadenaEncrypt)(password, privateKey);
        const incorrectPassword = 'wrongPassword';
        const changePasswordAttempt = () => (0, kadenaEncryption_js_1.kadenaChangePassword)(incorrectPassword, encryptedPrivateKey, newPassword);
        await (0, vitest_1.expect)(() => changePasswordAttempt()).rejects.toThrow('Failed to decrypt the private key with the old password: Decryption failed');
    });
    (0, vitest_1.it)('fails to decrypt with the old password after the password has been changed', async () => {
        const firstPassword = 'firstPassword123';
        const secondPassword = 'secondPassword123';
        const message = Buffer.from('test-message');
        const encryptedMessage = await (0, kadenaEncryption_js_1.kadenaEncrypt)(firstPassword, message);
        const newEncryptedMessage = await (0, kadenaEncryption_js_1.kadenaChangePassword)(firstPassword, encryptedMessage, secondPassword);
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaDecrypt)(firstPassword, newEncryptedMessage)).rejects.toThrow();
    });
    const testUndefined = undefined;
    const testNull = null;
    const testUnint8Array = Uint8Array.from({
        length: 32,
    });
    const testMessage = 'test-message';
    (0, vitest_1.it)('handles non-string inputs for private keys and passwords', async () => {
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaChangePassword)(password, testUndefined, newPassword)).rejects.toThrow();
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaChangePassword)(testUndefined, testMessage, newPassword)).rejects.toThrow();
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaChangePassword)(password, testMessage, testUndefined)).rejects.toThrow();
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaChangePassword)(password, testNull, newPassword)).rejects.toThrow();
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaChangePassword)(testNull, testUnint8Array, newPassword)).rejects.toThrow();
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaChangePassword)(password, testMessage, testNull)).rejects.toThrow();
        await (0, vitest_1.expect)(() => (0, kadenaEncryption_js_1.kadenaChangePassword)(password, testMessage, password)).rejects.toThrow();
    });
});
//# sourceMappingURL=kadenaEncryption.test.js.map